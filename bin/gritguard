#!/bin/bash
# GritGuard - Dynamic sandbox wrapper for AI agents
#
# Usage: gritguard <command> [args...]
#        gritguard selfassembler "Add feature" --repo /path/to/project
#
# Environment variables:
#   GRITGUARD_BASE_CONFIG - Path to base config (default: templates/base.json)
#   GRITGUARD_DEBUG       - Set to 1 for debug output

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
GRITGUARD_DIR="$(dirname "$SCRIPT_DIR")"

# Debug mode
debug() {
    if [[ "${GRITGUARD_DEBUG:-0}" == "1" ]]; then
        echo "[gritguard] $*" >&2
    fi
}

# Ensure .claude is a directory in the target to avoid srt/bwrap mount errors.
prepare_claude_dir() {
    local claude_dir="$TARGET_DIR/.claude"

    if [[ -e "$claude_dir" && ! -d "$claude_dir" ]]; then
        debug "Removing non-directory .claude at $claude_dir"
        rm -f "$claude_dir"
    fi

    mkdir -p "$claude_dir"
}

# Escape argv into a single shell string for srt. If the user passed a single
# argument, preserve it verbatim to allow intentional shell syntax.
shell_escape_args() {
    if [[ $# -le 1 ]]; then
        printf '%s' "$1"
        return 0
    fi

    local escaped=()
    local repl="'\"'\"'"
    local arg
    for arg in "$@"; do
        if [[ -z "$arg" ]]; then
            escaped+=("''")
            continue
        fi
        local safe=${arg//\'/$repl}
        escaped+=("'$safe'")
    done
    printf '%s' "${escaped[*]}"
}

shell_quote() {
    local repl="'\"'\"'"
    local safe=${1//\'/$repl}
    printf "'%s'" "$safe"
}

# Parse command line to find target directory and build command args
# Looks for --repo flag or uses current directory
# Sets TARGET_DIR and CMD_ARGS global variables
parse_args() {
    TARGET_DIR="$(pwd)"
    CMD_ARGS=()
    local skip_next=false

    for arg in "$@"; do
        if $skip_next; then
            TARGET_DIR="$arg"
            skip_next=false
            continue
        fi

        if [[ "$arg" == "--repo" ]]; then
            skip_next=true
            continue
        fi

        CMD_ARGS+=("$arg")
    done

    # Resolve to absolute path
    TARGET_DIR="$(cd "$TARGET_DIR" 2>/dev/null && pwd)" || TARGET_DIR="$TARGET_DIR"
}

# Main
if [[ $# -eq 0 ]]; then
    echo "Usage: gritguard <command> [args...]" >&2
    echo "" >&2
    echo "Examples:" >&2
    echo "  gritguard claude" >&2
    echo "  gritguard selfassembler \"Add feature\" --repo /path/to/project" >&2
    exit 1
fi

# Parse arguments - sets TARGET_DIR and CMD_ARGS
parse_args "$@"
debug "Target directory: $TARGET_DIR"
debug "Command args: ${CMD_ARGS[*]}"
CMD_STR="$(shell_escape_args "${CMD_ARGS[@]}")"

# Generate config
TEMP_CONFIG=$(mktemp --suffix=.json)
trap "rm -f '$TEMP_CONFIG'" EXIT

debug "Generating config to: $TEMP_CONFIG"
"$SCRIPT_DIR/generate-config" "$TARGET_DIR" > "$TEMP_CONFIG"

if [[ "${GRITGUARD_DEBUG:-0}" == "1" ]]; then
    debug "Generated config:"
    cat "$TEMP_CONFIG" >&2
fi

# Run in the target directory for consistent behavior with other wrappers.
prepare_claude_dir
NEEDS_SHELL_CD=0
if [[ -f "$TARGET_DIR/.git" ]]; then
    if [[ ! -s "$TARGET_DIR/.git" ]]; then
        debug "Removing empty .git file at $TARGET_DIR/.git"
        if rm -f "$TARGET_DIR/.git"; then
            mkdir -p "$TARGET_DIR/.git"
        else
            debug "Could not remove $TARGET_DIR/.git; will use shell cd"
            NEEDS_SHELL_CD=1
        fi
    else
        debug "Detected .git file (worktree); will use shell cd"
        NEEDS_SHELL_CD=1
    fi
fi

if [[ "$NEEDS_SHELL_CD" == "1" ]]; then
    CMD_STR="cd $(shell_quote "$TARGET_DIR") && $CMD_STR"
else
    cd "$TARGET_DIR"
fi

# Find srt executable
find_srt() {
    # Check PATH first
    if command -v srt &> /dev/null; then
        echo "srt"
        return 0
    fi

    # Check common locations
    local locations=(
        "$HOME/.npm/bin/srt"
        "$HOME/.local/bin/srt"
        "/usr/local/bin/srt"
        "$HOME/agent/.npm/bin/srt"
        "/home/erebus/agent/.npm/bin/srt"
    )

    for loc in "${locations[@]}"; do
        if [[ -x "$loc" ]]; then
            echo "$loc"
            return 0
        fi
    done

    return 1
}

SRT_CMD=$(find_srt) || {
    echo "Error: srt (sandbox-runtime) not found" >&2
    echo "Install with: npm install -g @anthropic-ai/sandbox-runtime" >&2
    exit 1
}

# Run command inside srt sandbox
debug "Running: $SRT_CMD --settings $TEMP_CONFIG \"$CMD_STR\""
exec "$SRT_CMD" --settings "$TEMP_CONFIG" "$CMD_STR"
